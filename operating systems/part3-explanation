What happens in stuckworker:After insmod,wait for thirty seconds and rmmod, the message"Your worker is clocking off" is displayed. But after that the module is not removed so it stucks forever. 

Analyse the cause of the problem: After rmmod command is typed, the cleanup_module start so the kernel thread is running at the same time as the cleanup module. please_clock_off is immediately set to be 1. After the 10-second cycle is finished, if-clause is immediately executed in the worker_routine because please_clock_off is equal to 1. And then the first process in waiting queue is wake up. But the first process in waiting queue is not rmmod command because the cleanup_module sleep for 12 seconds after it it set the current state to TASK_UNINTERRUPTIBLE. Therefore, the cleanup module miss the only oppotunity to wake up so the whole module cannot be removed and it stucks forever.

Solution for an SMP-safe worker: I use wait_event(wq,condition) to replace sleep_on(wq). The second argument condition is a flag for the event to wait for. As long as the condition is equal to 1, the event will wake up immediately. In the worker_routine, the flag "condition" is set to be 1 after the kernel thread is terminated. And then I can show the procedure followed. After the cleanup module is executed, please_clock_off is set to be 1 and cleanup is put into waiting queue. Because please_clock_off=1,the condition is set to be 1 and the kernel thread is terminate. Back to cleanup module, the thread may still sleep but when time is out, the first process in the waiting queue which is cleanup is wake up. Finally, the module is unloaded. This solution is working on SMP-safe system. By the way,there is another solution to modify stuckworker. I can set the sleep time of cleanup module to be a small value so it may not miss the oppotunity to wake up. But the right result is a contingency so I will not consider this solution.

